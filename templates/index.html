<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tien Len Mien Nam - Online</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0c3b2e, #1a5f7a);
            color: white;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        .background-pattern {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(circle at 25% 25%, rgba(255, 255, 255, 0.05) 2px, transparent 2px),
                radial-gradient(circle at 75% 75%, rgba(255, 255, 255, 0.05) 2px, transparent 2px);
            background-size: 100px 100px;
            z-index: -1;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 25px;
            background: rgba(0, 20, 40, 0.7);
            border-radius: 20px;
            border: 2px solid rgba(255, 215, 0, 0.3);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #FFD700, #FF6B6B, #4ECDC4);
        }

        h1 {
            color: #FFD700;
            font-size: 2.8em;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
            margin-bottom: 10px;
            letter-spacing: 2px;
        }

        .subtitle {
            color: #4ECDC4;
            font-size: 1.2em;
            margin-bottom: 20px;
        }

        .game-container {
            display: grid;
            grid-template-columns: 3fr 1fr;
            gap: 25px;
            margin-bottom: 25px;
        }

        .game-board {
            background: rgba(0, 20, 40, 0.8);
            border-radius: 20px;
            padding: 25px;
            border: 2px solid rgba(255, 215, 0, 0.2);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4);
            position: relative;
            min-height: 700px;
        }

        .game-canvas {
        width: 100%;
        height: 700px; /* Increased from 600px */
        background: rgba(0, 30, 60, 0.3); /* Lighter background to show more board */
        border-radius: 20px; /* Larger radius */
        margin-bottom: 20px;
        border: 2px solid rgba(255, 215, 0, 0.3); /* Thicker border */
        position: relative;
        overflow: hidden;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        cursor: pointer;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5); /* Added shadow */
    }
        canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
            border-radius: 15px;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            cursor: pointer;
        }

        .players-panel {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 25px;
        }

        .player-card {
            background: linear-gradient(145deg, rgba(0, 40, 80, 0.8), rgba(0, 20, 40, 0.9));
            border-radius: 15px;
            padding: 15px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .player-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #4ECDC4, #45B7D1);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .player-card.current-turn {
            border-color: #FFD700;
            box-shadow: 0 5px 20px rgba(255, 215, 0, 0.3);
            transform: translateY(-5px);
        }

        .player-card.current-turn::before {
            opacity: 1;
        }

        .player-card.winner {
            border-color: #4ECDC4;
            box-shadow: 0 5px 20px rgba(78, 205, 196, 0.4);
            background: linear-gradient(145deg, rgba(0, 60, 40, 0.8), rgba(0, 40, 20, 0.9));
        }

        .player-name {
            font-weight: bold;
            font-size: 1.2em;
            color: #FFD700;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .player-name i {
            font-size: 0.9em;
        }

        .player-cards {
            font-size: 1.4em;
            color: #4ECDC4;
            margin: 10px 0;
        }

        .player-status {
            font-size: 0.9em;
            color: #FF6B6B;
            margin-top: 5px;
        }

        /* UPDATED: Side action buttons next to hand */
        .side-controls {
            position: absolute;
            bottom: 180px; /* MOVED 40px HIGHER */
            right: 30px; /* Right side of game board */
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 100;
            background: rgba(0, 20, 40, 0.9);
            padding: 15px;
            border-radius: 15px;
            border: 2px solid rgba(255, 215, 0, 0.3);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            min-width: 140px;
        }

        .side-btn {
            background: linear-gradient(145deg, #2A4365, #1A365D);
            color: white;
            border: none;
            padding: 12px 15px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 0.95em;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.1);
            text-align: center;
        }

        .side-btn:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 7px 20px rgba(0, 0, 0, 0.4);
            border-color: rgba(255, 215, 0, 0.3);
        }

        .side-btn:active:not(:disabled) {
            transform: translateY(-1px);
        }

        .side-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .side-btn.play {
            background: linear-gradient(145deg, #38A169, #2F855A);
            animation: pulse-green 2s infinite;
        }

        .side-btn.pass {
            background: linear-gradient(145deg, #E53E3E, #C53030);
            animation: pulse-red 2s infinite;
        }

        .side-btn.three-spades-warning {
            background: linear-gradient(145deg, #D69E2E, #B7791F);
            animation: pulse-orange 1s infinite;
        }

        @keyframes pulse-green {
            0% { box-shadow: 0 0 0 0 rgba(56, 161, 105, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(56, 161, 105, 0); }
            100% { box-shadow: 0 0 0 0 rgba(56, 161, 105, 0); }
        }

        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(229, 62, 62, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(229, 62, 62, 0); }
            100% { box-shadow: 0 0 0 0 rgba(229, 62, 62, 0); }
        }

        @keyframes pulse-orange {
            0% { box-shadow: 0 0 0 0 rgba(214, 158, 46, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(214, 158, 46, 0); }
            100% { box-shadow: 0 0 0 0 rgba(214, 158, 46, 0); }
        }

        .side-btn i {
            font-size: 1em;
        }

        .controls-panel {
            background: rgba(0, 20, 40, 0.8);
            border-radius: 20px;
            padding: 25px;
            border: 2px solid rgba(255, 215, 0, 0.2);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4);
        }

        .controls-grid {
            display: grid;
            gap: 15px;
        }

        .btn {
            background: linear-gradient(145deg, #2A4365, #1A365D);
            color: white;
            border: none;
            padding: 16px 24px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            transition: all 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 7px 20px rgba(0, 0, 0, 0.4);
            border-color: rgba(255, 215, 0, 0.3);
        }

        .btn:active:not(:disabled) {
            transform: translateY(-1px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .btn-start {
            background: linear-gradient(145deg, #38A169, #2F855A);
        }

        .btn-hint {
            background: linear-gradient(145deg, #D69E2E, #B7791F);
        }

        .btn-restart {
            background: linear-gradient(145deg, #D69E2E, #B7791F);
        }

        .btn-restart:hover:not(:disabled) {
            background: linear-gradient(145deg, #ED8936, #DD6B20);
        }

        .btn i {
            font-size: 1.2em;
        }

        .selected-cards-display {
            background: rgba(0, 30, 60, 0.6);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .selected-title {
            color: #FFD700;
            margin-bottom: 10px;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .selected-cards {
            min-height: 60px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }

        .selected-card {
            width: 50px;
            height: 70px;
            background: white;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease;
            position: relative;
        }

        .selected-card.red {
            color: #C80000;
        }

        .selected-card.black {
            color: #000000;
        }

        .selected-card.three-spades {
            border: 3px solid #00FF00;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.7);
            transform: scale(1.05);
        }

        .selected-card.three-spades::after {
            content: '‚òÖ';
            position: absolute;
            top: -8px;
            right: -8px;
            color: #00FF00;
            font-size: 14px;
            background: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .game-info {
            background: rgba(0, 20, 40, 0.8);
            border-radius: 20px;
            padding: 25px;
            margin-top: 25px;
            border: 2px solid rgba(255, 215, 0, 0.2);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4);
            position: relative;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
        }

        .info-card {
            background: rgba(0, 30, 60, 0.6);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
        }

        .info-title {
            color: #4ECDC4;
            font-size: 0.9em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .info-value {
            color: #FFD700;
            font-size: 1.8em;
            font-weight: bold;
        }

        .three-spades-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 255, 0, 0.2);
            color: #00FF00;
            padding: 5px 15px;
            border-radius: 10px;
            font-size: 12px;
            border: 1px solid #00FF00;
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: bold;
        }

        .game-log {
            background: rgba(0, 20, 40, 0.8);
            border-radius: 20px;
            padding: 25px;
            margin-top: 25px;
            border: 2px solid rgba(255, 215, 0, 0.2);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4);
            max-height: 300px;
            overflow-y: auto;
        }

        .log-title {
            color: #FFD700;
            margin-bottom: 15px;
            font-size: 1.3em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .log-content {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.95em;
            line-height: 1.5;
        }

        .log-entry {
            padding: 8px 12px;
            margin-bottom: 5px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            border-left: 4px solid;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        @keyframes glow {
            from { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
            to { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 30px rgba(255, 215, 0, 0.4); }
        }

        @keyframes glow-green {
            from { box-shadow: 0 0 10px rgba(0, 255, 0, 0.5); }
            to { box-shadow: 0 0 20px rgba(0, 255, 0, 0.8), 0 0 30px rgba(0, 255, 0, 0.4); }
        }

        /* === NEW ANIMATIONS === */
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        @keyframes robotBounce {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            25% { transform: translateY(-10px) rotate(-5deg); }
            75% { transform: translateY(-10px) rotate(5deg); }
        }

        @keyframes confetti-fall {
            0% { transform: translateY(-100px) rotate(0deg); opacity: 1; }
            100% { transform: translateY(1000px) rotate(360deg); opacity: 0; }
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #FFD700;
            top: -10px;
            animation: confetti-fall 3s linear infinite;
        }

        .log-entry.player {
            border-left-color: #3182CE;
        }

        .log-entry.bot {
            border-left-color: #E53E3E;
        }

        .log-entry.system {
            border-left-color: #38A169;
        }

        .log-entry.winner {
            border-left-color: #FFD700;
            background: rgba(255, 215, 0, 0.1);
        }

        .log-entry.three-spades {
            border-left-color: #00FF00;
            background: rgba(0, 255, 0, 0.1);
        }

        .log-timestamp {
            color: #A0AEC0;
            font-size: 0.85em;
            margin-right: 10px;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal {
            background: linear-gradient(145deg, #0c3b2e, #1a5f7a);
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            border: 3px solid #FFD700;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
        }

        .modal h2 {
            color: #FFD700;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .modal p {
            margin-bottom: 30px;
            line-height: 1.6;
            color: #E2E8F0;
        }

        .modal-input {
            width: 100%;
            padding: 15px;
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #4ECDC4;
            border-radius: 10px;
            color: white;
            font-size: 1.1em;
            text-align: center;
        }

        .modal-input:focus {
            outline: none;
            border-color: #FFD700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        .glow {
            animation: glow 1.5s infinite alternate;
        }

        .glow-green {
            animation: glow-green 1.5s infinite alternate;
        }

        /* First Play Warning */
        .first-play-warning {
            background: linear-gradient(145deg, rgba(255, 215, 0, 0.2), rgba(255, 100, 100, 0.3)) !important;
            border: 2px solid #FF0000 !important;
            color: #FF0000 !important;
        }

        /* Round Starter Indicator */
        .round-starter {
            border: 3px solid #4ECDC4 !important;
            background: rgba(78, 205, 196, 0.1) !important;
        }

        /* 3‚ô† Highlight Styles */
        .three-spades-highlight {
            animation: glow-green 2s infinite alternate;
            border: 3px solid #00FF00 !important;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5) !important;
        }
                /* Bot name styling */
        .bot-name-display {
            position: absolute;
            background: rgba(0, 20, 40, 0.9);
            color: #FFD700;
            padding: 8px 15px;
            border-radius: 10px;
            font-weight: bold;
            font-size: 16px;
            border: 2px solid rgba(255, 215, 0, 0.3);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            z-index: 10;
            pointer-events: none;
        }

        /* Current bot turn highlight */
        .bot-name-display.current-turn {
            color: #00FF00;
            border-color: #00FF00;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
            animation: pulse-green 2s infinite;
        }

        /* === NEW STYLES FOR CARD SPACING AND AUTO WIN === */
        
        /* Better card selection visual */
        .card-selection-indicator {
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 20px;
            background: #FFD700;
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: #000;
            z-index: 10;
        }

        /* Automatic win notification */
        .auto-win-notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(145deg, rgba(255, 215, 0, 0.95), rgba(255, 140, 0, 0.95));
            color: #000;
            padding: 15px 30px;
            border-radius: 15px;
            border: 3px solid #FF0000;
            font-size: 20px;
            font-weight: bold;
            z-index: 1000;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            animation: autoWinPulse 2s infinite;
            display: none;
        }

        @keyframes autoWinPulse {
            0% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.05); }
            100% { transform: translateX(-50%) scale(1); }
        }

        /* Card count indicator */
        .card-count-badge {
            position: absolute;
            bottom: -10px;
            right: -10px;
            background: #FF0000;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        /* Card scroll indicator */
        .scroll-indicator {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #FFD700;
            font-size: 14px;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 15px;
            border-radius: 10px;
            display: none;
            z-index: 50;
        }

        /* Game state indicator */
        .game-state-indicator {
            position: fixed;
            top: 100px;
            right: 20px;
            background: rgba(0, 20, 40, 0.9);
            padding: 10px 15px;
            border-radius: 10px;
            border: 2px solid rgba(255, 215, 0, 0.3);
            font-size: 12px;
            max-width: 200px;
            z-index: 100;
        }

        /* Responsive design */
        @media (max-width: 1200px) {
            .game-container {
                grid-template-columns: 1fr;
            }
            
            .info-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .side-controls {
                right: 20px;
                bottom: 200px;
            }
        }

        @media (max-width: 768px) {
            .players-panel {
                grid-template-columns: 1fr;
            }
            
            .info-grid {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .side-controls {
                right: 15px;
                bottom: 200px;
                padding: 10px;
                min-width: 120px;
            }
            
            .side-btn {
                padding: 10px 12px;
                font-size: 0.85em;
            }
            
            .auto-win-notification {
                font-size: 16px;
                padding: 10px 20px;
                top: 10px;
            }
        }

        /* For very small screens */
        @media (max-width: 480px) {
            .game-canvas {
                height: 500px;
            }
            
            .side-controls {
                bottom: 150px;
                right: 10px;
                padding: 8px;
                min-width: 100px;
            }
            
            .side-btn {
                padding: 8px 10px;
                font-size: 0.8em;
            }
        }
    </style>
</head>
<body>
    <div class="background-pattern"></div>
    
    <div class="container">
        <header class="glow">
            <h1><i class="fas fa-cards"></i> TIEN LEN MIEN NAM <i class="fas fa-cards"></i></h1>
            <div class="subtitle">Vietnamese Card Game - Play Online with Beautiful Graphics</div>
        </header>
        
        <div class="game-container">
            <div class="game-board">
                <div class="game-canvas">
                    <canvas id="gameCanvas"></canvas>
                    <!-- Side action buttons next to hand -->
                    <div class="side-controls" id="sideControls" style="display: none;">
                        <button class="side-btn play" onclick="playSelectedCards()" id="btnPlay" disabled>
                            <i class="fas fa-play"></i> Play Cards
                        </button>
                        <button class="side-btn pass" onclick="passTurn()" id="btnPass" disabled>
                            <i class="fas fa-forward"></i> Pass
                        </button>
                    </div>
                </div>
                
                <div class="players-panel" id="playersPanel">
                    <!-- Player cards will be dynamically added -->
                </div>
            </div>
            
            <div class="controls-panel">
                <div class="controls-grid">
                    <button class="btn btn-start" onclick="showStartModal()" id="btnStart">
                        <i class="fas fa-play-circle"></i> Start New Game
                    </button>
                    
                    <!-- NEW RESTART BUTTON -->
                    <button class="btn btn-restart" onclick="restartGame()" id="btnRestart" disabled>
                        <i class="fas fa-redo"></i> Restart Game
                    </button>
                    
                    <button class="btn btn-hint" onclick="showHints()" id="btnHint" disabled>
                        <i class="fas fa-lightbulb"></i> Show Hints
                    </button>
                </div>
                
                <!-- DEBUG PANEL -->
                <div style="margin-top: 15px; padding: 10px; background: rgba(255,0,0,0.1); border-radius: 8px; border: 1px solid #FF6B6B;">
                    <div style="color: #FF6B6B; margin-bottom: 5px; font-size: 0.9em; display: flex; align-items: center; gap: 5px;">
                        <i class="fas fa-bug"></i> Debug Tools
                    </div>
                    <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                        <button onclick="debugGameState()" style="background: #555; color: white; border: none; padding: 5px 10px; border-radius: 5px; font-size: 0.8em; cursor: pointer;">
                            Log State
                        </button>
                        <button onclick="forceMyTurn()" style="background: #38A169; color: white; border: none; padding: 5px 10px; border-radius: 5px; font-size: 0.8em; cursor: pointer;">
                            Force My Turn
                        </button>
                        <button onclick="clearSelections()" style="background: #D69E2E; color: white; border: none; padding: 5px 10px; border-radius: 5px; font-size: 0.8em; cursor: pointer;">
                            Clear Selections
                        </button>
                    </div>
                </div>
                
                <div class="selected-cards-display">
                    <div class="selected-title">
                        <i class="fas fa-hand-pointer"></i> Selected Cards:
                    </div>
                    <div class="selected-cards" id="selectedCards">
                        <div style="color: #A0AEC0; font-style: italic;">No cards selected</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="game-info">
            <div class="info-grid">
                <div class="info-card">
                    <div class="info-title">Round</div>
                    <div class="info-value" id="roundNumber">-</div>
                </div>
                <div class="info-card">
                    <div class="info-title">Cards Left</div>
                    <div class="info-value" id="cardsLeft">-</div>
                </div>
                <div class="info-card">
                    <div class="info-title">Status</div>
                    <div class="info-value" id="gameStatus">Waiting</div>
                </div>
            </div>
        </div>
        
        <div class="game-log">
            <div class="log-title">
                <i class="fas fa-scroll"></i> Game Log
            </div>
            <div class="log-content" id="gameLog">
                <div class="log-entry system">
                    <span class="log-timestamp">[00:00:00]</span>
                    Welcome to Tien Len Mien Nam! Click "Start New Game" to begin.
                </div>
            </div>
        </div>
    </div>
    
    <!-- Start Game Modal -->
    <div class="overlay" id="startModal">
        <div class="modal">
            <h2><i class="fas fa-gamepad"></i> Start New Game</h2>
            <p>Enter your name to begin playing Tien Len against AI bots:</p>
            <input type="text" class="modal-input" id="playerName" placeholder="Enter your name" value="Player">
            <div style="display: flex; gap: 15px; margin-top: 20px;">
                <button class="btn btn-start" onclick="startGame()" style="flex: 1;">
                    <i class="fas fa-play"></i> Start Game
                </button>
                <button class="btn btn-pass" onclick="hideStartModal()" style="flex: 1;">
                    <i class="fas fa-times"></i> Cancel
                </button>
            </div>
        </div>
    </div>
    
    <!-- Hints Modal -->
    <div class="overlay" id="hintsModal">
        <div class="modal">
            <h2><i class="fas fa-lightbulb"></i> Available Plays</h2>
            <div id="hintsList" style="text-align: left; max-height: 300px; overflow-y: auto; margin-bottom: 20px;">
                <div style="color: #A0AEC0; text-align: center; padding: 20px;">
                    Loading available plays...
                </div>
            </div>
            <button class="btn btn-hint" onclick="hideHintsModal()">
                <i class="fas fa-times"></i> Close
            </button>
        </div>
    </div>

    <!-- JavaScript -->
    <script src="./static/cards.js"></script>
    <script>
        // Game state
        let gameState = {
            sessionId: null,
            gameId: null,
            players: [],
            playerHand: [],
            selectedCards: [],
            currentPlayer: null,
            lastPlay: null,
            gameOver: false,
            isPlayerTurn: false,
            canvas: null,
            ctx: null,
            cardRects: [],
            hoveredCard: -1,
            animations: [],
            botAnimations: [],
            isProcessingBotMove: false,
            hasShownWinCelebration: false,
            hasShownAutoWin: false, // NEW: Track auto win display
            botPassNotifications: new Set(),
            botTurnDelay: 900,
            botTurnTimeout: null,
            // NEW FIELDS FOR 3‚ô† RULE
            current_player_index: 0,
            first_player_index: 0,
            round_number: 1,
            rules_info: {
                requires_three_spades: false,
                three_spades_player: null,
                can_start_round: false
            },
            autoWinner: null // NEW: Track automatic winner
        };

        // ============ DEBUG FUNCTIONS ============
        function debugGameState() {
            console.log("=== DEBUG GAME STATE ===");
            console.log("Is player turn:", gameState.isPlayerTurn);
            console.log("Game over:", gameState.gameOver);
            console.log("Current player:", gameState.currentPlayer);
            console.log("Current player index:", gameState.current_player_index);
            console.log("First player index:", gameState.first_player_index);
            console.log("Round number:", gameState.round_number);
            console.log("Requires 3‚ô†:", gameState.rules_info.requires_three_spades);
            console.log("3‚ô† player:", gameState.rules_info.three_spades_player);
            console.log("Your hand size:", gameState.playerHand.length);
            console.log("Selected cards:", gameState.selectedCards);
            console.log("Selected cards count:", gameState.selectedCards.length);
            console.log("Card rects count:", gameState.cardRects.length);
            console.log("Last play:", gameState.lastPlay);
            console.log("Bot animations:", gameState.botAnimations.length);
            console.log("Auto winner:", gameState.autoWinner);
            console.log("=======================");
        }

        function debugAPIResponse(data) {
            console.log("=== API RESPONSE ===");
            console.log("Success:", data.success);
            console.log("Error:", data.error);
            if (data.state) {
                console.log("Is player turn:", data.state.is_player_turn);
                console.log("Current player:", data.state.current_player);
                console.log("Game over:", data.state.game_over);
                console.log("Round:", data.state.summary?.round);
                console.log("Requires 3‚ô†:", data.state.rules_info?.requires_three_spades);
                console.log("Auto winner:", data.state.summary?.auto_winner);
            }
            console.log("====================");
        }
        // =========================================

        // Bot animation helper function
        function createBotAnimation(botName, cardStr) {
            if (!gameState.ctx || !gameState.canvas) return;
            
            // Convert card string to card object
            const rankMap = {
                '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10,
                'J': 11, 'Q': 12, 'K': 13, 'A': 14, '2': 2
            };
            
            // Parse card string (e.g., "3‚ô†", "J‚ô•")
            let rankPart = cardStr.slice(0, -1);
            let suit = cardStr.slice(-1);
            let rank = rankMap[rankPart] || parseInt(rankPart);
            
            const card = {
                rank: rank,
                suit: suit,
                display: cardStr
            };
            
            // Get bot position based on bot name
            const canvasWidth = gameState.canvas.width;
            const canvasHeight = gameState.canvas.height;
            let fromX, fromY;
            
            if (botName.includes('Bot 1')) {
                fromX = 70;
                fromY = 100;
            } else if (botName.includes('Bot 2')) {
                fromX = canvasWidth - 280;
                fromY = 100;
            } else if (botName.includes('Bot 3')) {
                fromX = 70;
                fromY = canvasHeight - 280;
            } else {
                // Default position
                fromX = canvasWidth / 2;
                fromY = 100;
            }
            
            // Destination (center of play area)
            const centerX = canvasWidth / 2;
            const centerY = canvasHeight / 2;
            const toX = centerX - 30;
            const toY = centerY - 42;
            
            // Create animation
            const animation = cardRenderer.createBotPlayAnimation(botName, card, fromX, fromY, toX, toY);
            gameState.botAnimations.push(animation);
            
            // Special animation for 3‚ô†
            if (card.rank === 3 && card.suit === '‚ô†') {
                const threeSpadesAnim = cardRenderer.createThreeSpadesAnimation(card, toX, toY);
                gameState.botAnimations.push(threeSpadesAnim);
            }
            
            // Play sound effect
            playCardSound();
        }

        // Simple sound effect
        function playCardSound() {
            try {
                // Create a simple beep sound
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 523.25; // C5 note
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
            } catch (e) {
                console.log("Audio not supported");
            }
        }

        // Bot pass notification function
        function showBotPassNotification(botName) {
            // Check if there's already a notification for this bot
            const existingNotification = document.querySelector(`.bot-pass-notification[data-bot="${botName}"]`);
            if (existingNotification) {
                return; // Don't show duplicate
            }
            
            // Create notification element
            const notification = document.createElement('div');
            notification.className = 'bot-pass-notification';
            notification.setAttribute('data-bot', botName);
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 20, 40, 0.95);
                color: white;
                padding: 20px 40px;
                border-radius: 15px;
                border: 3px solid #FF6B6B;
                font-size: 24px;
                font-weight: bold;
                z-index: 1000;
                text-align: center;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
                animation: popInOut 2s ease-in-out forwards;
                pointer-events: none;
            `;
            
            notification.innerHTML = `
                <div style="color: #FF6B6B; font-size: 28px; margin-bottom: 10px;">
                    <i class="fas fa-forward"></i>
                </div>
                <div>${botName}</div>
                <div style="color: #FFD700; font-size: 32px; margin-top: 10px;">PASSED!</div>
            `;
            
            // Add to document
            document.body.appendChild(notification);
            
            // Remove after animation
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
                gameState.botPassNotifications.delete(botName);
            }, 2000);
        }

        // Show automatic win notification
        function showAutomaticWinNotification(playerName, reason) {
            const existingNotification = document.getElementById('autoWinNotification');
            if (existingNotification) {
                return; // Already showing
            }
            
            const notification = document.createElement('div');
            notification.className = 'auto-win-notification';
            notification.id = 'autoWinNotification';
            notification.innerHTML = `
                <div style="font-size: 24px; margin-bottom: 5px;">üèÜ AUTOMATIC WIN! üèÜ</div>
                <div style="font-weight: bold; font-size: 22px;">${playerName}</div>
                <div style="font-size: 18px; margin-top: 5px; color: #8B0000;">${reason}</div>
            `;
            
            document.body.appendChild(notification);
            notification.style.display = 'block';
            
            // Play victory sound
            playVictorySound();
            
            // Remove after 5 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 5000);
        }

        // Show player win celebration
        function showPlayerWinCelebration() {
            if (document.getElementById('winCelebration')) {
                return;
            }
            
            const celebration = document.createElement('div');
            celebration.id = 'winCelebration';
            celebration.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.85);
                z-index: 2000;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                animation: fadeIn 0.5s ease-out;
            `;
            
            celebration.innerHTML = `
                <div style="
                    text-align: center;
                    color: white;
                    padding: 40px;
                    background: linear-gradient(145deg, rgba(255, 215, 0, 0.2), rgba(212, 175, 55, 0.3));
                    border-radius: 20px;
                    border: 5px solid #FFD700;
                    max-width: 600px;
                    box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
                    position: relative;
                    overflow: hidden;
                ">
                    <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; overflow: hidden; pointer-events: none;">
                        <div class="confetti"></div>
                        <div class="confetti"></div>
                        <div class="confetti"></div>
                        <div class="confetti"></div>
                        <div class="confetti"></div>
                    </div>
                    
                    <div style="font-size: 80px; margin-bottom: 20px; animation: bounce 1s infinite;">
                        üèÜ
                    </div>
                    
                    <h1 style="color: #FFD700; font-size: 48px; margin-bottom: 20px; text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);">
                        VICTORY!
                    </h1>
                    
                    <div style="font-size: 32px; margin-bottom: 30px; color: #4ECDC4;">
                        You are the Tien Len Master! üéâ
                    </div>
                    
                    <div style="font-size: 18px; margin-bottom: 40px; color: #E2E8F0;">
                        Congratulations! You've outplayed all the bots and won the game!
                    </div>
                    
                    <div style="display: flex; gap: 20px; margin-top: 30px;">
                        <button onclick="restartGame()" style="
                            background: linear-gradient(145deg, #38A169, #2F855A);
                            color: white;
                            border: none;
                            padding: 15px 30px;
                            border-radius: 10px;
                            font-size: 18px;
                            font-weight: bold;
                            cursor: pointer;
                            display: flex;
                            align-items: center;
                            gap: 10px;
                            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
                            transition: all 0.3s;
                        ">
                            <i class="fas fa-redo"></i> Play Again
                        </button>
                        
                        <button onclick="hideWinCelebration()" style="
                            background: linear-gradient(145deg, #E53E3E, #C53030);
                            color: white;
                            border: none;
                            padding: 15px 30px;
                            border-radius: 10px;
                            font-size: 18px;
                            font-weight: bold;
                            cursor: pointer;
                            display: flex;
                            align-items: center;
                            gap: 10px;
                            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
                            transition: all 0.3s;
                        ">
                            <i class="fas fa-times"></i> Close
                        </button>
                    </div>
                    
                    <div style="margin-top: 30px; font-size: 14px; color: #A0AEC0;">
                        <i class="fas fa-trophy"></i> You've proven your Tien Len skills!
                    </div>
                </div>
            `;
            
            const winStyle = document.createElement('style');
            winStyle.textContent = `
                @keyframes fadeIn {
                    from { opacity: 0; }
                    to { opacity: 1; }
                }
                
                @keyframes bounce {
                    0%, 100% { transform: translateY(0); }
                    50% { transform: translateY(-20px); }
                }
                
                @keyframes confetti-fall {
                    0% { transform: translateY(-100px) rotate(0deg); opacity: 1; }
                    100% { transform: translateY(1000px) rotate(360deg); opacity: 0; }
                }
                
                .confetti {
                    position: absolute;
                    width: 10px;
                    height: 10px;
                    background: #FFD700;
                    top: -10px;
                    animation: confetti-fall 3s linear infinite;
                }
                
                .confetti:nth-child(1) { left: 10%; animation-delay: 0s; background: #FF6B6B; }
                .confetti:nth-child(2) { left: 30%; animation-delay: 0.5s; background: #4ECDC4; }
                .confetti:nth-child(3) { left: 50%; animation-delay: 1s; background: #FFD700; }
                .confetti:nth-child(4) { left: 70%; animation-delay: 1.5s; background: #95E1D3; }
                .confetti:nth-child(5) { left: 90%; animation-delay: 2s; background: #FF8E53; }
            `;
            
            document.head.appendChild(winStyle);
            document.body.appendChild(celebration);
            
            playVictorySound();
        }

        // Show bot win announcement
        function showBotWinCelebration(botName) {
            if (document.getElementById('botWinCelebration')) {
                return;
            }
            
            const celebration = document.createElement('div');
            celebration.id = 'botWinCelebration';
            celebration.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.85);
                z-index: 2000;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                animation: fadeIn 0.5s ease-out;
            `;
            
            celebration.innerHTML = `
                <div style="
                    text-align: center;
                    color: white;
                    padding: 40px;
                    background: linear-gradient(145deg, rgba(229, 62, 62, 0.2), rgba(197, 48, 48, 0.3));
                    border-radius: 20px;
                    border: 5px solid #E53E3E;
                    max-width: 600px;
                    box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
                    position: relative;
                    overflow: hidden;
                ">
                    <div style="font-size: 80px; margin-bottom: 20px; animation: robotBounce 1s infinite;">
                        ü§ñ
                    </div>
                    
                    <h1 style="color: #E53E3E; font-size: 48px; margin-bottom: 20px; text-shadow: 0 0 10px rgba(229, 62, 62, 0.5);">
                        ${botName} WINS!
                    </h1>
                    
                    <div style="font-size: 32px; margin-bottom: 30px; color: #FF6B6B;">
                        Better luck next time! üíî
                    </div>
                    
                    <div style="font-size: 18px; margin-bottom: 40px; color: #E2E8F0;">
                        ${botName} has outsmarted you this time. The AI prevails!
                    </div>
                    
                    <div style="
                        background: rgba(0, 0, 0, 0.3);
                        padding: 20px;
                        border-radius: 10px;
                        margin-bottom: 30px;
                        border-left: 4px solid #4ECDC4;
                    ">
                        <div style="font-size: 16px; color: #A0AEC0; margin-bottom: 10px;">
                            <i class="fas fa-robot"></i> AI Victory Analysis:
                        </div>
                        <div style="font-size: 14px; color: #CBD5E0;">
                            ‚Ä¢ Strategic card play<br>
                            ‚Ä¢ Effective bomb usage<br>
                            ‚Ä¢ Smart passing decisions
                        </div>
                    </div>
                    
                    <div style="display: flex; gap: 20px; margin-top: 20px;">
                        <button onclick="restartGame()" style="
                            background: linear-gradient(145deg, #D69E2E, #B7791F);
                            color: white;
                            border: none;
                            padding: 15px 30px;
                            border-radius: 10px;
                            font-size: 18px;
                            font-weight: bold;
                            cursor: pointer;
                            display: flex;
                            align-items: center;
                            gap: 10px;
                            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
                            transition: all 0.3s;
                        ">
                            <i class="fas fa-redo"></i> Try Again
                        </button>
                        
                        <button onclick="hideBotWinCelebration()" style="
                            background: linear-gradient(145deg, #2D3748, #4A5568);
                            color: white;
                            border: none;
                            padding: 15px 30px;
                            border-radius: 10px;
                            font-size: 18px;
                            font-weight: bold;
                            cursor: pointer;
                            display: flex;
                            align-items: center;
                            gap: 10px;
                            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
                            transition: all 0.3s;
                        ">
                            <i class="fas fa-times"></i> Close
                        </button>
                    </div>
                    
                    <div style="margin-top: 30px; font-size: 14px; color: #A0AEC0;">
                        <i class="fas fa-lightbulb"></i> Tip: Watch how bots play to improve your strategy!
                    </div>
                </div>
            `;
            
            const botStyle = document.createElement('style');
            botStyle.textContent += `
                @keyframes robotBounce {
                    0%, 100% { transform: translateY(0) rotate(0deg); }
                    25% { transform: translateY(-10px) rotate(-5deg); }
                    75% { transform: translateY(-10px) rotate(5deg); }
                }
            `;
            
            document.head.appendChild(botStyle);
            document.body.appendChild(celebration);
            
            playBotWinSound();
        }

        // Hide win celebrations
        function hideWinCelebration() {
            const celebration = document.getElementById('winCelebration');
            if (celebration) {
                celebration.style.animation = 'fadeOut 0.5s ease-out';
                setTimeout(() => celebration.remove(), 500);
            }
        }

        function hideBotWinCelebration() {
            const celebration = document.getElementById('botWinCelebration');
            if (celebration) {
                celebration.style.animation = 'fadeOut 0.5s ease-out';
                setTimeout(() => celebration.remove(), 500);
            }
        }

        // Sound effects
        function playVictorySound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const notes = [523.25, 659.25, 783.99, 1046.50];
                let time = audioContext.currentTime;
                
                notes.forEach((frequency, index) => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0, time);
                    gainNode.gain.linearRampToValueAtTime(0.2, time + 0.1);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
                    
                    oscillator.start(time);
                    oscillator.stop(time + 0.5);
                    
                    time += 0.15;
                });
            } catch (e) {
                console.log("Audio not supported");
            }
        }

        function playBotWinSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 349.23;
                oscillator.type = 'sawtooth';
                
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 1);
            } catch (e) {
                console.log("Audio not supported");
            }
        }

        // DOM elements
        const gameCanvas = document.getElementById('gameCanvas');
        const playersPanel = document.getElementById('playersPanel');
        const selectedCardsDiv = document.getElementById('selectedCards');
        const gameLog = document.getElementById('gameLog');
        const roundNumber = document.getElementById('roundNumber');
        const cardsLeft = document.getElementById('cardsLeft');
        const gameStatus = document.getElementById('gameStatus');
        const startModal = document.getElementById('startModal');
        const hintsModal = document.getElementById('hintsModal');
        const hintsList = document.getElementById('hintsList');
        const playerNameInput = document.getElementById('playerName');
        const sideControls = document.getElementById('sideControls');
        const btnPlay = document.getElementById('btnPlay');
        const btnPass = document.getElementById('btnPass');

        // Initialize canvas
        function initCanvas() {
            gameState.canvas = gameCanvas;
            gameState.ctx = gameCanvas.getContext('2d');
            
            const container = gameCanvas.parentElement;
            gameCanvas.width = container.clientWidth;
            gameCanvas.height = container.clientHeight;
            
            console.log(`Canvas initialized: ${gameCanvas.width}x${gameCanvas.height}`);
            
            requestAnimationFrame(render);
        }

        // Render game - UPDATED WITH CORRECT BOT PLACEMENT AND NAMES
        function render() {
            const ctx = gameState.ctx;
            const canvas = gameState.canvas;
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            
            // ===== DRAW LARGER GAME BOARD =====
            const boardPadding = 15;
            const boardX = boardPadding;
            const boardY = boardPadding;
            const boardWidth = canvasWidth - (boardPadding * 2);
            const boardHeight = canvasHeight - (boardPadding * 2);

            // Draw board background with rich gradient
            const boardGradient = ctx.createLinearGradient(
                boardX, boardY, 
                boardX + boardWidth, boardY + boardHeight
            );
            boardGradient.addColorStop(0, 'rgba(100, 0, 0, 0.95)');
            boardGradient.addColorStop(0.5, 'rgba(80, 0, 20, 0.95)');
            boardGradient.addColorStop(1, 'rgba(60, 0, 0, 0.95)');

            ctx.fillStyle = boardGradient;
            ctx.beginPath();
            if (ctx.roundRect) {
                ctx.roundRect(boardX, boardY, boardWidth, boardHeight, 20);
            } else {
                const radius = 20;
                ctx.moveTo(boardX + radius, boardY);
                ctx.lineTo(boardX + boardWidth - radius, boardY);
                ctx.quadraticCurveTo(boardX + boardWidth, boardY, boardX + boardWidth, boardY + radius);
                ctx.lineTo(boardX + boardWidth, boardY + boardHeight - radius);
                ctx.quadraticCurveTo(boardX + boardWidth, boardY + boardHeight, boardX + boardWidth - radius, boardY + boardHeight);
                ctx.lineTo(boardX + radius, boardY + boardHeight);
                ctx.quadraticCurveTo(boardX, boardY + boardHeight, boardX, boardY + boardHeight - radius);
                ctx.lineTo(boardX, boardY + radius);
                ctx.quadraticCurveTo(boardX, boardY, boardX + radius, boardY);
            }
            ctx.closePath();
            ctx.fill();

            // Thicker border with inner glow
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.9)';
            ctx.lineWidth = 6;
            ctx.stroke();
            
            // Inner border
            ctx.strokeStyle = 'rgba(255, 255, 100, 0.4)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw board title
            ctx.fillStyle = 'rgba(255, 215, 0, 0.95)';
            ctx.font = 'bold 26px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            
            // Title with glow effect
            ctx.shadowColor = 'rgba(255, 215, 0, 0.5)';
            ctx.shadowBlur = 8;
            ctx.fillText('üé¥ TIEN LEN MIEN NAM üé¥', canvasWidth / 2, boardY + 15);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;

            // Add subtle decorative patterns in corners
            ctx.save();
            ctx.globalAlpha = 0.15;
            ctx.fillStyle = '#FFD700';
            
            // Corner decorations
            const cornerSize = 15;
            // Top-left
            ctx.beginPath();
            ctx.moveTo(boardX + cornerSize, boardY + 5);
            ctx.lineTo(boardX + 5, boardY + cornerSize);
            ctx.lineTo(boardX + cornerSize, boardY + cornerSize);
            ctx.fill();
            // Top-right
            ctx.beginPath();
            ctx.moveTo(boardX + boardWidth - cornerSize, boardY + 5);
            ctx.lineTo(boardX + boardWidth - 5, boardY + cornerSize);
            ctx.lineTo(boardX + boardWidth - cornerSize, boardY + cornerSize);
            ctx.fill();
            // Bottom-left
            ctx.beginPath();
            ctx.moveTo(boardX + cornerSize, boardY + boardHeight - 5);
            ctx.lineTo(boardX + 5, boardY + boardHeight - cornerSize);
            ctx.lineTo(boardX + cornerSize, boardY + boardHeight - cornerSize);
            ctx.fill();
            // Bottom-right
            ctx.beginPath();
            ctx.moveTo(boardX + boardWidth - cornerSize, boardY + boardHeight - 5);
            ctx.lineTo(boardX + boardWidth - 5, boardY + boardHeight - cornerSize);
            ctx.lineTo(boardX + boardWidth - cornerSize, boardY + boardHeight - cornerSize);
            ctx.fill();
            
            ctx.restore();

            // Add subtle pattern to board background
            ctx.save();
            ctx.globalAlpha = 0.08;
            const patternSize = 60;
            for (let x = boardX; x < boardX + boardWidth; x += patternSize) {
                for (let y = boardY; y < boardY + boardHeight; y += patternSize) {
                    ctx.beginPath();
                    // Draw simple flower pattern
                    ctx.arc(x + patternSize/2, y + patternSize/2, 5, 0, Math.PI * 2);
                    ctx.fillStyle = '#FFD700';
                    ctx.fill();
                }
            }
            ctx.restore();

            // Center highlight area
            const centerX = canvasWidth / 2;
            const centerY = canvasHeight / 2;
            const highlightRadius = Math.min(boardWidth, boardHeight) * 0.18;

            ctx.save();
            ctx.globalAlpha = 0.2;
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(centerX, centerY, highlightRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // ===== DRAW LAST PLAY (IF ANY) =====
            if (gameState.lastPlay && gameState.lastPlay.cards && gameState.lastPlay.cards.length > 0) {
                const cards = gameState.lastPlay.cards.map(cardStr => {
                    const suit = cardStr.slice(-1);
                    const rankStr = cardStr.slice(0, -1);
                    const rankMap = {
                        'J': 11, 'Q': 12, 'K': 13, 'A': 14,
                        '2': 2, '3': 3, '4': 4, '5': 5, '6': 6,
                        '7': 7, '8': 8, '9': 9, '10': 10
                    };
                    return {
                        rank: rankMap[rankStr] || parseInt(rankStr),
                        suit: suit,
                        display: cardStr
                    };
                });
                
                cardRenderer.drawPlayArea(ctx, cards, centerX, centerY, canvasWidth);
                
                // Draw last play info
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.beginPath();
                if (ctx.roundRect) {
                    ctx.roundRect(centerX - 140, centerY - highlightRadius - 40, 280, 30, 10);
                } else {
                    const rectX = centerX - 140;
                    const rectY = centerY - highlightRadius - 40;
                    const radius = 10;
                    ctx.moveTo(rectX + radius, rectY);
                    ctx.lineTo(rectX + 280 - radius, rectY);
                    ctx.quadraticCurveTo(rectX + 280, rectY, rectX + 280, rectY + radius);
                    ctx.lineTo(rectX + 280, rectY + 30 - radius);
                    ctx.quadraticCurveTo(rectX + 280, rectY + 30, rectX + 280 - radius, rectY + 30);
                    ctx.lineTo(rectX + radius, rectY + 30);
                    ctx.quadraticCurveTo(rectX, rectY + 30, rectX, rectY + 30 - radius);
                    ctx.lineTo(rectX, rectY + radius);
                    ctx.quadraticCurveTo(rectX, rectY, rectX + radius, rectY);
                }
                ctx.closePath();
                ctx.fill();
                
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`Last Play: ${gameState.lastPlay.player}`, centerX, centerY - highlightRadius - 25);
            } else {
                // Draw "No play yet" text
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.beginPath();
                if (ctx.roundRect) {
                    ctx.roundRect(centerX - 150, centerY - 30, 300, 60, 15);
                } else {
                    const rectX = centerX - 150;
                    const rectY = centerY - 30;
                    const radius = 15;
                    ctx.moveTo(rectX + radius, rectY);
                    ctx.lineTo(rectX + 300 - radius, rectY);
                    ctx.quadraticCurveTo(rectX + 300, rectY, rectX + 300, rectY + radius);
                    ctx.lineTo(rectX + 300, rectY + 60 - radius);
                    ctx.quadraticCurveTo(rectX + 300, rectY + 60, rectX + 300 - radius, rectY + 60);
                    ctx.lineTo(rectX + radius, rectY + 60);
                    ctx.quadraticCurveTo(rectX, rectY + 60, rectX, rectY + 60 - radius);
                    ctx.lineTo(rectX, rectY + radius);
                    ctx.quadraticCurveTo(rectX, rectY, rectX + radius, rectY);
                }
                ctx.closePath();
                ctx.fill();
                
                ctx.fillStyle = '#4ECDC4';
                ctx.font = 'italic 22px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('No cards played yet', centerX, centerY - 10);
                
                ctx.font = '16px Arial';
                ctx.fillStyle = '#A0AEC0';
                ctx.fillText('Start the round!', centerX, centerY + 15);
            }
            
            // Draw game info overlay
            cardRenderer.drawGameInfo(ctx, gameState, canvasWidth, canvasHeight);
            
            // Draw bot animations
            if (gameState.botAnimations && gameState.botAnimations.length > 0) {
                cardRenderer.drawBotAnimations(ctx, gameState.botAnimations);
                gameState.botAnimations = cardRenderer.updateAnimations(gameState.botAnimations);
            }
            
            // Draw regular animations
            gameState.animations = gameState.animations.filter(anim => {
                const progress = Math.min(1, (Date.now() - anim.startTime) / anim.duration);
                
                if (progress >= 1) return false;
                
                const easedProgress = progress < 0.5 
                    ? 2 * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                
                const currentX = anim.fromX + (anim.toX - anim.fromX) * easedProgress;
                const currentY = anim.fromY + (anim.toY - anim.fromY) * easedProgress;
                
                cardRenderer.drawCardFace(ctx, anim.card, currentX, currentY, false, false, true, true);
                
                return true;
            });
            
            // ===== DRAW PLAYER'S HAND (ALWAYS CENTERED) =====
            if (gameState.playerHand.length > 0) {
                const handY = canvasHeight - 130; // Position near bottom
                
                // Draw player's hand - cards.js handles centering
                gameState.cardRects = cardRenderer.drawHand(
                    ctx,
                    gameState.playerHand,
                    handY,
                    gameState.selectedCards,
                    gameState.hoveredCard,
                    canvasWidth
                );
            }
            
            // ===== DRAW BOTS' HANDS WITH CORRECT PLACEMENT AND NAMES =====
            if (gameState.players && gameState.players.length >= 4) {
                // Get bot players (indices 1-3)
                const bot1 = gameState.players[1]; // Bot 1
                const bot2 = gameState.players[2]; // Bot 2  
                const bot3 = gameState.players[3]; // Bot 3
                
                // Draw Bot 1 (Top-center) - JUST DRAW THE HAND, NAME IS ALREADY INCLUDED
                if (bot1 && bot1.name) {
                    const bot1X = canvasWidth / 2 - 370;
                    const bot1Y = 120;
                    cardRenderer.drawBotHand(
                        ctx,
                        bot1.cards_remaining,
                        bot1X,
                        bot1Y,
                        bot1.name === gameState.currentPlayer,
                        canvasWidth,
                        1 // Bot index for name display
                    );
                }
                
                // Draw Bot 2 (Right side) - JUST DRAW THE HAND, NAME IS ALREADY INCLUDED
                if (bot2 && bot2.name) {
                    const bot2X = canvasWidth - 220;
                    const bot2Y = canvasHeight / 2 - 140;
                    cardRenderer.drawBotHand(
                        ctx,
                        bot2.cards_remaining,
                        bot2X,
                        bot2Y,
                        bot2.name === gameState.currentPlayer,
                        canvasWidth,
                        2 // Bot index for name display
                    );
                }
                
                // Draw Bot 3 (Left side) - JUST DRAW THE HAND, NAME IS ALREADY INCLUDED
                if (bot3 && bot3.name) {
                    const bot3X = 100;
                    const bot3Y = canvasHeight / 2 - 60;
                    cardRenderer.drawBotHand(
                        ctx,
                        bot3.cards_remaining,
                        bot3X,
                        bot3Y,
                        bot3.name === gameState.currentPlayer,
                        canvasWidth,
                        3 // Bot index for name display
                    );
                }
            }
            

            
            // Draw current turn indicator
            if (gameState.currentPlayer) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.beginPath();
                if (ctx.roundRect) {
                    ctx.roundRect(centerX - 150, boardY + 105, 300, 25, 8);
                }
                ctx.closePath();
                ctx.fill();
                
                ctx.fillStyle = gameState.isPlayerTurn ? '#00FF00' : '#FFD700';
                ctx.font = 'bold 16px Arial';
                ctx.fillText(`Turn: ${gameState.currentPlayer}`, centerX, boardY + 120);
                
                // Add blinking effect for current player's turn
                if (gameState.isPlayerTurn && Math.floor(Date.now() / 500) % 2 === 0) {
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                    ctx.beginPath();
                    ctx.arc(centerX - 70, boardY + 120, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.restore();
            
            requestAnimationFrame(render);
        }
        // Event handling
        let isProcessingClick = false;
        let lastClickTime = 0;
        const CLICK_DEBOUNCE_MS = 300;
        
        // Handle mouse move for hover effects
        let hoverUpdateTimeout = null;
        gameCanvas.addEventListener('mousemove', (e) => {
            if (!gameState.isPlayerTurn || gameState.gameOver) return;
            
            const rect = gameCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            let foundHover = -1;
            for (const cardRect of gameState.cardRects) {
                if (x >= cardRect.x && x <= cardRect.x + cardRect.width &&
                    y >= cardRect.y && y <= cardRect.y + cardRect.height) {
                    foundHover = cardRect.index;
                    break;
                }
            }
            
            if (gameState.hoveredCard !== foundHover) {
                gameState.hoveredCard = foundHover;
                
                if (hoverUpdateTimeout) {
                    clearTimeout(hoverUpdateTimeout);
                }
                hoverUpdateTimeout = setTimeout(() => {
                    requestAnimationFrame(render);
                }, 16);
            }
        });
        
        // Clear hover when mouse leaves canvas
        gameCanvas.addEventListener('mouseleave', () => {
            if (gameState.hoveredCard !== -1) {
                gameState.hoveredCard = -1;
                requestAnimationFrame(render);
            }
        });
        
        // Handle mouse down
        gameCanvas.addEventListener('mousedown', function(e) {
            handleCanvasClick(e.clientX, e.clientY, e);
        });
        
        // Handle touch for mobile
        gameCanvas.addEventListener('touchstart', function(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                handleCanvasClick(touch.clientX, touch.clientY, e);
            }
        }, { passive: false });
        
        // Prevent context menu
        gameCanvas.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            return false;
        });
        
        // Handle canvas click - UPDATED with more forgiving click detection
        function handleCanvasClick(clientX, clientY, e) {
            if (!gameState.isPlayerTurn || gameState.gameOver) {
                return;
            }
            
            const now = Date.now();
            if (now - lastClickTime < CLICK_DEBOUNCE_MS) {
                return;
            }
            lastClickTime = now;
            
            if (e) {
                e.stopPropagation();
                e.preventDefault();
            }
            
            const rect = gameCanvas.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            
            let clickedIndex = -1;
            
            // Make click detection more forgiving - check a slightly larger area
            // Add 10px margin around card for easier clicking
            const clickMargin = 10;
            for (let i = 0; i < gameState.cardRects.length; i++) {
                const cardRect = gameState.cardRects[i];
                if (x >= cardRect.x - clickMargin && x <= cardRect.x + cardRect.width + clickMargin &&
                    y >= cardRect.y - clickMargin && y <= cardRect.y + cardRect.height + clickMargin) {
                    clickedIndex = i;
                    break;
                }
            }
            
            if (clickedIndex === -1) {
                return;
            }
            
            if (!isProcessingClick) {
                isProcessingClick = true;
                setTimeout(() => {
                    toggleCardSelection(clickedIndex);
                    isProcessingClick = false;
                }, 50);
            }
        }

        // Toggle card selection - UPDATED WITH 3‚ô† HIGHLIGHTING
        function toggleCardSelection(index) {
            if (!gameState.isPlayerTurn || gameState.gameOver) {
                return;
            }
            
            const card = gameState.playerHand[index];
            if (!card) {
                return;
            }
            
            const isSelected = gameState.selectedCards.includes(index);
            
            if (isSelected) {
                gameState.selectedCards = gameState.selectedCards.filter(i => i !== index);
                addLog('system', `Deselected: ${card.display}`);
            } else {
                gameState.selectedCards.push(index);
                addLog('system', `Selected: ${card.display}`);
                
                // Special log for 3‚ô†
                if (card.rank === 3 && card.suit === '‚ô†') {
                    addLog('three-spades', `‚òÖ Selected 3‚ô†! This card must be included in first play.`);
                }
                
                // Special log for 2s (automatic win card)
                if (card.rank === 2) {
                    addLog('system', `‚ú® Selected 2 (automatic win card)`);
                }
            }
            
            updateSelectedCardsDisplay();
            updateSideButtons();
        }

        // Update selected cards display - UPDATED WITH 3‚ô† HIGHLIGHTING
        function updateSelectedCardsDisplay() {
            selectedCardsDiv.innerHTML = '';
            
            if (gameState.selectedCards.length === 0) {
                selectedCardsDiv.innerHTML = '<div style="color: #A0AEC0; font-style: italic;">No cards selected</div>';
                return;
            }
            
            const sortedSelected = [...gameState.selectedCards].sort((a, b) => a - b);
            
            // Check if we have 3‚ô† selected
            let hasThreeSpades = false;
            sortedSelected.forEach(cardIndex => {
                const card = gameState.playerHand[cardIndex];
                if (card && card.rank === 3 && card.suit === '‚ô†') {
                    hasThreeSpades = true;
                }
            });
            
            // Add warning if 3‚ô† is required but not selected
            if (gameState.rules_info && gameState.rules_info.requires_three_spades && 
                gameState.current_player_index === 0 && !hasThreeSpades && sortedSelected.length > 0) {
                const warning = document.createElement('div');
                warning.style.cssText = `
                    width: 100%;
                    background: rgba(255, 0, 0, 0.1);
                    color: #FF0000;
                    padding: 10px;
                    border-radius: 8px;
                    margin-bottom: 10px;
                    text-align: center;
                    font-weight: bold;
                    border: 1px solid #FF0000;
                `;
                warning.innerHTML = `<i class="fas fa-exclamation-triangle"></i> First play must include 3‚ô†!`;
                selectedCardsDiv.appendChild(warning);
            }
            
            sortedSelected.forEach(cardIndex => {
                const card = gameState.playerHand[cardIndex];
                if (!card) return;
                
                const cardDiv = document.createElement('div');
                const isThreeSpades = (card.rank === 3 && card.suit === '‚ô†');
                const isTwo = (card.rank === 2);
                cardDiv.className = `selected-card ${card.suit === '‚ô•' || card.suit === '‚ô¶' ? 'red' : 'black'} ${isThreeSpades ? 'three-spades' : ''} ${isTwo ? 'two-card' : ''}`;
                
                const rankSymbol = cardRenderer.rankToSymbol(card.rank);
                cardDiv.innerHTML = `
                    <div style="font-size: 16px; ${isThreeSpades ? 'color: #00AA00; font-weight: bold;' : (isTwo ? 'color: #DAA520; font-weight: bold;' : '')}">
                        ${rankSymbol}
                    </div>
                    <div style="font-size: 20px;">${card.suit}</div>
                `;
                
                // Add special indicator for automatic win cards
                if (isThreeSpades || isTwo) {
                    const indicator = document.createElement('div');
                    indicator.style.cssText = `
                        position: absolute;
                        top: -8px;
                        right: -8px;
                        background: ${isThreeSpades ? '#00FF00' : '#FFD700'};
                        color: #000;
                        width: 20px;
                        height: 20px;
                        border-radius: 50%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 12px;
                        font-weight: bold;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                    `;
                    indicator.textContent = isThreeSpades ? '‚ô†' : '2';
                    cardDiv.appendChild(indicator);
                }
                
                selectedCardsDiv.appendChild(cardDiv);
            });
            
            const countDiv = document.createElement('div');
            countDiv.style.cssText = `
                width: 100%;
                text-align: center;
                color: #FFD700;
                margin-top: 10px;
                font-weight: bold;
            `;
            countDiv.textContent = `${gameState.selectedCards.length} card${gameState.selectedCards.length !== 1 ? 's' : ''} selected`;
            selectedCardsDiv.appendChild(countDiv);
        }

        // Show start modal
        function showStartModal() {
            startModal.style.display = 'flex';
            playerNameInput.focus();
            playerNameInput.select();
        }

        // Hide start modal
        function hideStartModal() {
            startModal.style.display = 'none';
        }

        // Start game
        async function startGame() {
            const playerName = playerNameInput.value.trim() || 'Player';
            hideStartModal();
            
            try {
                const response = await fetch('/api/start_game', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        player_name: playerName
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    gameState.sessionId = data.session_id;
                    gameState.gameId = data.game_id;
                    gameState.hasShownWinCelebration = false;
                    gameState.hasShownAutoWin = false;
                    gameState.autoWinner = null;
                    
                    addLog('system', `Welcome, ${playerName}! Game started.`);
                    
                    // Check for 3‚ô† player
                    if (data.state && data.state.rules_info) {
                        const threeSpadesPlayer = data.state.rules_info.three_spades_player;
                        if (threeSpadesPlayer && threeSpadesPlayer.includes('You')) {
                            addLog('three-spades', `‚ú® You have 3‚ô†! You must include it in your first play.`);
                        } else if (threeSpadesPlayer) {
                            addLog('system', `‚ú® ${threeSpadesPlayer} has 3‚ô† and will start the game.`);
                        }
                    }
                    
                    updateGameState();
                    
                    document.getElementById('btnHint').disabled = false;
                    document.getElementById('btnStart').disabled = true;
                    sideControls.style.display = 'flex';
                    
                    setInterval(updateGameState, 1000);
                } else {
                    addLog('system', `Error: ${data.error}`);
                }
            } catch (error) {
                addLog('system', `Network error: ${error}`);
            }
        }

        // Update game state - UPDATED WITH AUTO WIN HANDLING
        async function updateGameState() {
            if (!gameState.sessionId || gameState.isProcessingBotMove) {
                return;
            }
            
            try {
                const response = await fetch(`/api/get_state?session_id=${gameState.sessionId}`);
                
                if (!response.ok) {
                    if (response.status === 0 || response.status >= 500) {
                        addLog('system', '‚ö†Ô∏è Server connection lost. Try restarting the game.');
                        return;
                    }
                }
                
                const data = await response.json();
                debugAPIResponse(data);
                
                if (data.success) {
                    const state = data.state;
                    
                    // ===== AUTOMATIC WIN HANDLING =====
                    if (state.summary && state.summary.auto_winner) {
                        // Automatic win detected!
                        const autoWinner = state.summary.auto_winner;
                        
                        // Update game state with auto win info
                        gameState.autoWinner = autoWinner;
                        gameState.gameOver = true;
                        gameState.isPlayerTurn = false;
                        
                        // Show automatic win notification (only once)
                        if (!gameState.hasShownAutoWin) {
                            showAutomaticWinNotification(autoWinner.player, autoWinner.reason);
                            gameState.hasShownAutoWin = true;
                            
                            // Log the automatic win
                            addLog('winner', `üéâ ${autoWinner.player} wins automatically! (${autoWinner.reason})`);
                        }
                        
                        // Disable all player controls
                        disablePlayControls();
                        
                        // Don't process further updates for auto-win
                        return;
                    } else {
                        // Clear auto win state if no auto winner
                        gameState.autoWinner = null;
                        gameState.hasShownAutoWin = false;
                    }
                    // ===== END AUTOMATIC WIN HANDLING =====
                    
                    // Update game state (normal case)
                    gameState.players = state.players || [];
                    gameState.playerHand = state.player_hand || [];
                    gameState.lastPlay = state.last_play;
                    gameState.gameOver = state.game_over || false;
                    gameState.isPlayerTurn = state.is_player_turn || false;
                    gameState.currentPlayer = state.current_player;
                    gameState.current_player_index = state.current_player_index || 0;
                    gameState.first_player_index = state.first_player_index || 0;
                    gameState.round_number = state.summary?.round || 1;
                    gameState.rules_info = state.rules_info || {};
                    
                    // Update cardRenderer game state
                    cardRenderer.updateGameState({
                        round_number: gameState.round_number,
                        rules_info: gameState.rules_info,
                        current_player_index: gameState.current_player_index,
                        first_player_index: gameState.first_player_index,
                        current_player: gameState.currentPlayer,
                        is_player_turn: gameState.isPlayerTurn,
                        auto_winner: gameState.autoWinner
                    });
                    
                    // Update UI
                    updatePlayersPanel();
                    updateGameInfo(state.summary);
                    updateGameStatus();
                    updateSideButtons();
                    
                    // Update log with recent plays
                    if (state.round_plays && state.round_plays.length > 0) {
                        const recent = state.round_plays.slice(-3);
                        recent.forEach(play => {
                            if (!logContains(play)) {
                                addLog('system', play);
                            }
                        });
                    }
                    
                    // Check for normal winner (not auto win)
                    if (state.winner && !gameState.hasShownWinCelebration && !gameState.autoWinner) {
                        addLog('winner', `üéâ ${state.winner} wins the game! üéâ`);
                        disableGameControls();
                        gameState.hasShownWinCelebration = true;
                        
                        setTimeout(() => {
                            if (state.winner.includes('You') || state.winner.includes('Player')) {
                                showPlayerWinCelebration();
                            } else {
                                showBotWinCelebration(state.winner);
                            }
                        }, 1000);
                    }
                    
                    // Process bot moves (only if no auto win)
                    if (!gameState.autoWinner && 
                        !gameState.isPlayerTurn && 
                        !gameState.gameOver && 
                        gameState.currentPlayer && 
                        gameState.currentPlayer.includes('Bot') && 
                        !gameState.isProcessingBotMove) {
                        
                        if (gameState.botTurnTimeout) {
                            clearTimeout(gameState.botTurnTimeout);
                        }
                        
                        gameState.botTurnTimeout = setTimeout(async () => {
                            try {
                                gameState.isProcessingBotMove = true;
                                
                                const response = await fetch('/api/bot_move', {
                                    method: 'POST',
                                    headers: {'Content-Type': 'application/json'},
                                    body: JSON.stringify({
                                        session_id: gameState.sessionId
                                    })
                                });
                                
                                const data = await response.json();
                                
                                if (data.success) {
                                    if (data.message && data.message.includes('passed')) {
                                        if (!gameState.botPassNotifications.has(gameState.currentPlayer)) {
                                            showBotPassNotification(gameState.currentPlayer);
                                            gameState.botPassNotifications.add(gameState.currentPlayer);
                                        }
                                    } else {
                                        gameState.botPassNotifications.clear();
                                    }
                                    
                                    const message = data.message || '';
                                    if (message.includes('played')) {
                                        const parts = message.split('played ');
                                        if (parts.length > 1) {
                                            const cardsStr = parts[1].replace('.', '');
                                            const cards = cardsStr.split(' ').filter(c => c.trim());
                                            
                                            cards.forEach(card => {
                                                if (card) {
                                                    createBotAnimation(gameState.currentPlayer, card);
                                                }
                                            });
                                            
                                            setTimeout(() => {
                                                gameState.isProcessingBotMove = false;
                                                updateGameState();
                                            }, 1000);
                                        } else {
                                            setTimeout(() => {
                                                gameState.isProcessingBotMove = false;
                                                updateGameState();
                                            }, 800);
                                        }
                                    } else {
                                        setTimeout(() => {
                                            gameState.isProcessingBotMove = false;
                                            updateGameState();
                                        }, gameState.botTurnDelay);
                                    }
                                    
                                    addLog('bot', data.message);
                                } else {
                                    console.error("Bot move failed:", data.error);
                                    gameState.isProcessingBotMove = false;
                                    setTimeout(() => updateGameState(), gameState.botTurnDelay);
                                }
                            } catch (error) {
                                console.error('Error processing bot move:', error);
                                gameState.isProcessingBotMove = false;
                                setTimeout(() => updateGameState(), gameState.botTurnDelay);
                            }
                        }, gameState.botTurnDelay);
                    }
                }
            } catch (error) {
                console.error('Error updating game state:', error);
                
                if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                    addLog('system', '‚ö†Ô∏è Cannot connect to server. The server may have crashed.');
                } else {
                    addLog('system', `Error: ${error.message}`);
                }
            }
        }

        // Update side buttons state - UPDATED WITH 3‚ô† WARNING
        function updateSideButtons() {
            if (gameState.isPlayerTurn && !gameState.gameOver && !gameState.autoWinner) {
                const canPlay = gameState.selectedCards.length > 0;
                let playButtonText = "Play Cards";
                let buttonClass = "play";
                
                // Check if player must play 3‚ô†
                if (gameState.rules_info && gameState.rules_info.requires_three_spades && 
                    gameState.current_player_index === 0) {
                    
                    // Check if selected cards contain 3‚ô†
                    const hasThreeSpades = gameState.selectedCards.some(cardIndex => {
                        const card = gameState.playerHand[cardIndex];
                        return card && card.rank === 3 && card.suit === '‚ô†';
                    });
                    
                    if (canPlay && !hasThreeSpades) {
                        playButtonText = "Must include 3‚ô†!";
                        buttonClass = "three-spades-warning";
                        btnPlay.style.background = 'linear-gradient(145deg, #D69E2E, #B7791F)';
                        btnPlay.style.animation = 'pulse-orange 1s infinite';
                    } else if (canPlay && hasThreeSpades) {
                        playButtonText = "Play Cards (3‚ô† included ‚úì)";
                        buttonClass = "play";
                        btnPlay.style.background = 'linear-gradient(145deg, #38A169, #2F855A)';
                        btnPlay.style.animation = 'pulse-green 2s infinite';
                    } else {
                        playButtonText = "Must play 3‚ô†";
                        buttonClass = "";
                        btnPlay.style.background = 'linear-gradient(145deg, #2A4365, #1A365D)';
                        btnPlay.style.animation = 'none';
                    }
                } else {
                    btnPlay.style.background = 'linear-gradient(145deg, #38A169, #2F855A)';
                    btnPlay.style.animation = canPlay ? 'pulse-green 2s infinite' : 'none';
                }
                
                // Update button text and class
                btnPlay.innerHTML = `<i class="fas fa-play"></i> ${playButtonText}`;
                btnPlay.className = `side-btn ${buttonClass}`;
                
                btnPlay.disabled = !canPlay;
                btnPass.disabled = false;
            } else {
                btnPlay.disabled = true;
                btnPass.disabled = true;
                btnPlay.innerHTML = `<i class="fas fa-play"></i> Play Cards`;
                btnPlay.style.background = 'linear-gradient(145deg, #38A169, #2F855A)';
                btnPlay.style.animation = 'none';
                btnPlay.className = 'side-btn';
            }
            
            if (gameState.sessionId) {
                document.getElementById('btnRestart').disabled = false;
            }
        }

        // Update players panel - UPDATED WITH 3‚ô† HIGHLIGHTING
        function updatePlayersPanel() {
            playersPanel.innerHTML = '';
            
            gameState.players.forEach(player => {
                const playerCard = document.createElement('div');
                playerCard.className = 'player-card';
                
                if (player.name === gameState.currentPlayer) {
                    playerCard.classList.add('current-turn');
                }
                
                // Highlight 3‚ô† holder
                if (gameState.rules_info && gameState.rules_info.three_spades_player === player.name) {
                    playerCard.style.border = '3px solid #00FF00';
                    playerCard.style.boxShadow = '0 0 15px rgba(0, 255, 0, 0.3)';
                }
                
                if (player.has_won) {
                    playerCard.classList.add('winner');
                }
                
                const icon = player.name.includes('Bot') ? 'fa-robot' : 'fa-user';
                const isThreeSpadesHolder = gameState.rules_info && gameState.rules_info.three_spades_player === player.name;
                const isRoundStarter = gameState.first_player_index !== undefined && 
                                      gameState.players[gameState.first_player_index] && 
                                      gameState.players[gameState.first_player_index].name === player.name;
                
                playerCard.innerHTML = `
                    <div class="player-name">
                        <i class="fas ${icon}"></i> ${player.name}
                        ${isThreeSpadesHolder ? 
                          '<span style="color: #00FF00; margin-left: 5px;"><i class="fas fa-star"></i> 3‚ô†</span>' : ''}
                    </div>
                    <div class="player-cards">
                        <i class="fas fa-cards"></i> ${player.cards_remaining} cards
                    </div>
                    ${player.has_won ? '<div class="player-status"><i class="fas fa-trophy"></i> WINNER!</div>' : ''}
                    ${player.name === gameState.currentPlayer ? '<div class="player-status"><i class="fas fa-play-circle"></i> Current Turn</div>' : ''}
                    ${isRoundStarter ? '<div class="player-status"><i class="fas fa-flag"></i> Starts Round</div>' : ''}
                `;
                
                playersPanel.appendChild(playerCard);
            });
        }

        // Update game info - UPDATED WITH 3‚ô† INDICATOR
        function updateGameInfo(summary) {
            if (summary) {
                roundNumber.textContent = summary.round || '-';
                cardsLeft.textContent = summary.current_player_cards || '-';
                
                // Update game status based on auto win
                if (summary.auto_winner) {
                    gameStatus.textContent = `üéâ ${summary.auto_winner.player} wins automatically!`;
                    gameStatus.style.color = '#FFD700';
                }
                
                // Add or update 3‚ô† indicator
                if (summary.three_spades_player) {
                    let indicator = document.getElementById('threeSpadesIndicator');
                    if (!indicator) {
                        indicator = document.createElement('div');
                        indicator.id = 'threeSpadesIndicator';
                        indicator.className = 'three-spades-indicator';
                        document.querySelector('.game-info').appendChild(indicator);
                    }
                    indicator.innerHTML = `<i class="fas fa-star"></i> 3‚ô†: ${summary.three_spades_player}`;
                    indicator.style.display = 'flex';
                } else {
                    const indicator = document.getElementById('threeSpadesIndicator');
                    if (indicator) {
                        indicator.style.display = 'none';
                    }
                }
            }
        }

        // Update game status - UPDATED WITH 3‚ô† RULE
        function updateGameStatus() {
            if (gameState.gameOver || gameState.autoWinner) {
                if (gameState.autoWinner) {
                    gameStatus.textContent = `üéâ ${gameState.autoWinner.player} wins automatically!`;
                    gameStatus.style.color = '#FFD700';
                } else {
                    gameStatus.textContent = 'Game Over';
                    gameStatus.style.color = '#FF6B6B';
                }
                gameStatus.classList.remove('pulse');
            } else if (gameState.isPlayerTurn) {
                // Check if player must play 3‚ô† (first play of first game)
                if (gameState.rules_info && gameState.rules_info.requires_three_spades && 
                    gameState.current_player_index === 0) {
                    gameStatus.textContent = 'Your Turn (Must play 3‚ô†!)';
                    gameStatus.style.color = '#FF0000';
                    gameStatus.style.textShadow = '0 0 10px rgba(255, 0, 0, 0.5)';
                } else if (gameState.rules_info && gameState.rules_info.can_start_round && 
                           gameState.current_player_index === 0) {
                    gameStatus.textContent = 'Your Turn (You start this round)';
                    gameStatus.style.color = '#4ECDC4';
                } else {
                    gameStatus.textContent = 'Your Turn';
                    gameStatus.style.color = '#4ECDC4';
                }
                gameStatus.classList.add('pulse');
            } else {
                // Show who has 3‚ô† if it's first round
                if (gameState.rules_info && gameState.rules_info.requires_three_spades) {
                    gameStatus.textContent = `Waiting for ${gameState.currentPlayer || 'Bots'} (${gameState.rules_info.three_spades_player} has 3‚ô†)`;
                } else {
                    gameStatus.textContent = `Waiting for ${gameState.currentPlayer || 'Bots'}`;
                }
                gameStatus.style.color = '#A0AEC0';
                gameStatus.classList.remove('pulse');
            }
        }

        // Play selected cards - UPDATED WITH 3‚ô† VALIDATION
        async function playSelectedCards() {
            if (gameState.selectedCards.length === 0 || !gameState.isPlayerTurn) {
                addLog('system', 'Please select cards to play');
                return;
            }
            
            // Check if 3‚ô† is required
            if (gameState.rules_info && gameState.rules_info.requires_three_spades && 
                gameState.current_player_index === 0) {
                
                const hasThreeSpades = gameState.selectedCards.some(cardIndex => {
                    const card = gameState.playerHand[cardIndex];
                    return card && card.rank === 3 && card.suit === '‚ô†';
                });
                
                if (!hasThreeSpades) {
                    addLog('system', '‚ùå First play must include 3‚ô†!');
                    
                    // Visual feedback
                    btnPlay.style.animation = 'none';
                    setTimeout(() => {
                        btnPlay.style.animation = 'pulse-red 0.5s 3';
                    }, 10);
                    
                    return;
                }
            }
            
            const cardsToPlay = gameState.selectedCards.map(idx => {
                const card = gameState.playerHand[idx];
                return `${cardRenderer.rankToSymbol(card.rank)}${card.suit}`;
            });
            
            try {
                const response = await fetch('/api/play_cards', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        session_id: gameState.sessionId,
                        cards: cardsToPlay
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    addLog('player', data.message);
                    
                    // Special log for 3‚ô† play
                    if (cardsToPlay.some(card => card.includes('3‚ô†'))) {
                        addLog('three-spades', `‚òÖ Played with 3‚ô†!`);
                    }
                    
                    const centerX = gameState.canvas.width / 2;
                    const centerY = gameState.canvas.height / 2;
                    
                    gameState.selectedCards.forEach((cardIndex, i) => {
                        const card = gameState.playerHand[cardIndex];
                        const cardRect = gameState.cardRects[cardIndex];
                        
                        if (card && cardRect) {
                            gameState.animations.push({
                                card: card,
                                fromX: cardRect.x,
                                fromY: cardRect.y,
                                toX: centerX - 100 + i * 70,
                                toY: centerY - 50,
                                startTime: Date.now(),
                                duration: 500
                            });
                        }
                    });
                    
                    gameState.selectedCards = [];
                    updateSelectedCardsDisplay();
                    
                    setTimeout(() => {
                        updateGameState();
                    }, 800);
                } else {
                    addLog('system', `Error: ${data.error}`);
                }
            } catch (error) {
                addLog('system', `Network error: ${error}`);
            }
        }

        // Pass turn
        async function passTurn() {
            if (!gameState.isPlayerTurn) {
                return;
            }
            
            try {
                const response = await fetch('/api/pass_turn', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        session_id: gameState.sessionId
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    addLog('player', data.message);
                    
                    setTimeout(() => {
                        updateGameState();
                    }, 800);
                } else {
                    addLog('system', `Error: ${data.error}`);
                }
            } catch (error) {
                addLog('system', `Network error: ${error}`);
            }
        }

        // Show hints
        async function showHints() {
            if (!gameState.sessionId) return;
            
            try {
                const response = await fetch(`/api/get_valid_plays?session_id=${gameState.sessionId}`);
                const data = await response.json();
                
                if (data.success && data.valid_plays && data.valid_plays.length > 0) {
                    hintsList.innerHTML = '';
                    
                    // Add 3‚ô† rule info
                    if (data.requires_three_spades) {
                        const ruleInfo = document.createElement('div');
                        ruleInfo.style.cssText = `
                            padding: 10px;
                            margin-bottom: 15px;
                            background: rgba(0, 255, 0, 0.1);
                            border-radius: 8px;
                            border-left: 4px solid #00FF00;
                            color: #00FF00;
                        `;
                        ruleInfo.innerHTML = `
                            <div style="font-weight: bold; margin-bottom: 5px;">
                                <i class="fas fa-star"></i> First Play Rule:
                            </div>
                            <div style="font-size: 0.9em;">
                                Must include 3‚ô†. ${data.three_spades_player} has 3‚ô†.
                            </div>
                        `;
                        hintsList.appendChild(ruleInfo);
                    }
                    
                    data.valid_plays.slice(0, 10).forEach((hint, i) => {
                        const hintItem = document.createElement('div');
                        hintItem.style.padding = '10px';
                        hintItem.style.marginBottom = '5px';
                        hintItem.style.background = hint.is_valid ? 'rgba(255, 255, 255, 0.1)' : 'rgba(255, 0, 0, 0.1)';
                        hintItem.style.borderRadius = '8px';
                        hintItem.style.borderLeft = `4px solid ${hint.is_valid ? '#FFD700' : '#FF0000'}`;
                        
                        hintItem.innerHTML = `
                            <div style="font-weight: bold; color: ${hint.is_valid ? '#FFD700' : '#FF0000'}">
                                ${i + 1}. ${hint.cards.join(' ')}
                                ${!hint.is_valid ? ' ‚ùå' : ''}
                            </div>
                            <div style="font-size: 0.9em; color: #A0AEC0; margin-top: 5px;">
                                Type: ${hint.type} | Cards: ${hint.count}
                                ${hint.error ? `<br><span style="color: #FF6B6B;">${hint.error}</span>` : ''}
                            </div>
                        `;
                        
                        hintsList.appendChild(hintItem);
                    });
                    
                    hintsModal.style.display = 'flex';
                } else {
                    addLog('system', 'No valid plays available');
                }
            } catch (error) {
                console.error('Error getting hints:', error);
            }
        }

        // Hide hints modal
        function hideHintsModal() {
            hintsModal.style.display = 'none';
        }

        // Restart game function
        async function restartGame() {
            hideWinCelebration();
            hideBotWinCelebration();
            
            // Remove auto win notification if present
            const autoWinNotification = document.getElementById('autoWinNotification');
            if (autoWinNotification) {
                autoWinNotification.remove();
            }
            
            gameState.hasShownWinCelebration = false;
            gameState.hasShownAutoWin = false;
            gameState.botPassNotifications.clear();
            gameState.autoWinner = null;
            
            document.querySelectorAll('.bot-pass-notification').forEach(el => el.remove());
            
            if (gameState.botTurnTimeout) {
                clearTimeout(gameState.botTurnTimeout);
                gameState.botTurnTimeout = null;
            }
            
            if (!gameState.sessionId) {
                addLog('system', 'No game to restart');
                return;
            }
            
            try {
                const playerName = document.getElementById('playerName').value.trim() || 'Player';
                
                const response = await fetch('/api/restart_game', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        player_name: playerName
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    addLog('system', 'Game restarted!');
                    
                    gameState.sessionId = data.session_id;
                    gameState.gameId = data.game_id;
                    
                    gameState.selectedCards = [];
                    updateSelectedCardsDisplay();
                    
                    updateGameState();
                    
                    document.getElementById('btnHint').disabled = false;
                    document.getElementById('btnRestart').disabled = false;
                    
                    const firstLog = gameLog.firstElementChild;
                    gameLog.innerHTML = '';
                    if (firstLog) {
                        gameLog.appendChild(firstLog);
                    }
                    
                    addLog('system', `Game restarted for ${playerName}`);
                } else {
                    addLog('system', `Error restarting: ${data.error}`);
                }
            } catch (error) {
                addLog('system', `Network error: ${error}`);
            }
        }

        // Add log entry - UPDATED WITH 3‚ô† HIGHLIGHTING
        function addLog(type, message) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            
            // Highlight 3‚ô† plays
            if (message.includes('3‚ô†') || (type === 'three-spades')) {
                logEntry.innerHTML = `
                    <span class="log-timestamp">[${timestamp}]</span> 
                    <span style="color: #00FF00; font-weight: bold;">
                        <i class="fas fa-star"></i> ${message}
                    </span>
                `;
            }
            // Highlight bot passes
            else if (type === 'bot' && message.includes('passed')) {
                logEntry.innerHTML = `
                    <span class="log-timestamp">[${timestamp}]</span> 
                    <span style="color: #FF6B6B; font-weight: bold;">
                        <i class="fas fa-forward"></i> ${message}
                    </span>
                `;
            }
            else if (type === 'winner') {
                logEntry.innerHTML = `
                    <span class="log-timestamp">[${timestamp}]</span> 
                    <span style="color: #FFD700; font-weight: bold; font-size: 1.1em;">
                        <i class="fas fa-trophy"></i> ${message}
                    </span>
                `;
            }
            else {
                logEntry.innerHTML = `
                    <span class="log-timestamp">[${timestamp}]</span> ${message}
                `;
            }
            
            gameLog.appendChild(logEntry);
            gameLog.scrollTop = gameLog.scrollHeight;
        }

        // Check if log contains message
        function logContains(message) {
            return gameLog.innerHTML.includes(message);
        }

        // Disable game controls
        function disableGameControls() {
            btnPlay.disabled = true;
            btnPass.disabled = true;
            document.getElementById('btnHint').disabled = true;
        }
        // NEW FUNCTION: Disable only play controls, not restart
        function disablePlayControls() {
            btnPlay.disabled = true;
            btnPass.disabled = true;
            document.getElementById('btnHint').disabled = true;
            // Restart button remains enabled
}
        // Initialize when page loads
        window.addEventListener('load', () => {
            console.log("üéÆ Game script loading...");
            initCanvas();
            addLog('system', 'Game loaded. Click "Start New Game" to begin!');
            
            // Handle Enter key in player name input
            playerNameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    startGame();
                }
            });
            
            // Handle window resize
            window.addEventListener('resize', () => {
                const container = gameCanvas.parentElement;
                gameCanvas.width = container.clientWidth;
                gameCanvas.height = container.clientHeight;
                console.log(`Canvas resized: ${gameCanvas.width}x${gameCanvas.height}`);
                
                // Re-render immediately after resize
                requestAnimationFrame(render);
            });
            
            // ============ DEBUG HELPER FUNCTIONS ============
            window.debugGameState = debugGameState;
            
            function forceMyTurn() {
                console.log("‚ö†Ô∏è FORCING PLAYER TURN");
                gameState.isPlayerTurn = true;
                gameState.currentPlayer = "You";
                gameState.current_player_index = 0;
                updateSideButtons();
                console.log("‚úÖ Player turn forced ON");
                debugGameState();
            }
            
            function clearSelections() {
                console.log("üßπ Clearing all selections");
                gameState.selectedCards = [];
                updateSelectedCardsDisplay();
                updateSideButtons();
                console.log("‚úÖ Selections cleared");
            }
            
            // Add fadeOut animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes fadeOut {
                    from { opacity: 1; }
                    to { opacity: 0; }
                }
                @keyframes popInOut {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
                    30% { transform: translate(-50%, -50%) scale(1); }
                    70% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    100% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                }
                @keyframes autoWinPulse {
                    0% { transform: translateX(-50%) scale(1); }
                    50% { transform: translateX(-50%) scale(1.05); }
                    100% { transform: translateX(-50%) scale(1); }
                }
            `;
            document.head.appendChild(style);
            
            console.log("üéÆ Game script loaded successfully");
        });
    </script>
</body>
</html>